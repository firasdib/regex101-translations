{
    "'{0}' found at index {1}": "'{0}' ditemukan pada indeks {1}",
    "(except for line terminators)": "(kecuali pada pengakhir baris)",
    "{1} — Matches between {2} and {3} times, {4} {5}": "{1} — Cocok diantara {2} dan {3} kali, {4} {5}",
    "{1} — Matches exactly {2} {3} {4}": "",
    "{1} Alternative": "",
    "{1} and {2} are also available with the use of '{3}'": "",
    "{1} can be used to match the same text the third preceding capture group matched and captured.": "",
    "{1} Capturing Group": "",
    "{1} checks whether the {2} capturing group matched when it was last attempted": "",
    "{1} checks whether the {2} subroutine matches": "",
    "{1} checks whether the whole pattern matches": "",
    "{1} is a line separator which can stand for {2}, {3}, {4}, or {5}.": "",
    "{1} is a paragraph separator (PS) character.": "",
    "{1} is NEL, next line character.": "",
    "{1} match": "",
    "{1} matches": "",
    "{1} modifier:": "",
    "{1} step": "",
    "{1} steps": "",
    "{1} subpattern": "",
    "{1} unit test": "",
    "{1} upvotes, {2} downvotes ({3}% like it)": "",
    "{1} would be the second previous capture group, for example. {2} would be the third capture group.": "",
    "{1}, matches any position": "",
    "{1}. A {2} followed by a letter with no special meaning is faulted": "",
    "{1}. A dot won't match {2}": "",
    "{1}. All capturing groups {2} are instead treated as if they were non-capturing groups {3}.": "",
    "{1}. All matches (don't return after first match)": "",
    "{1}. Capturing groups {2} are no longer treated as if they were non-capturing groups {3}.": "",
    "{1}. Case insensitive match (ignores case of {2})": "",
    "{1}. Case sensitive match": "",
    "{1}. Causes {2} and {3} to match begin/end of string": "",
    "{1}. Causes {2} and {3} to match the begin/end of each line (not only begin/end of string)": "",
    "{1}. Dot matches newline characters {2}": "",
    "{1}. Enable all unicode features and interpret all unicode escape sequences as such": "",
    "{1}. Force the a dollar sign, {2}, to always match end of the string, instead of end of the line. This option is ignored if the {3}-flag is set": "",
    "{1}. Force the escape sequences {2}, {3}, {4}, {5}, {6}, {7}, {8} and {9} to perform ASCII-only matching instead of full Unicode matching": "",
    "{1}. Force the pattern to only match consecutive matches from where the previous match ended.": "",
    "{1}. Make {2}, {3}, {4}, {5}, {6}, {7}, {8} and {9} perform matching with Unicode semantic (redundant in Python 3)": "",
    "{1}. Pattern is forced to {2}": "",
    "{1}. Pattern strings are treated as {2}. Also causes escape sequences to match unicode characters": "",
    "{1}. Spaces and text after a {2} in the pattern are ignored": "",
    "{1}. Spaces and text after a {2} in the pattern are ignored (even whitespace inside character classes)": "",
    "{1}. The match becomes greedy by default": "",
    "{1}. The match becomes lazy by default. Now a {2} following a quantifier makes it greedy": "",
    "{1}. Whitespaces and {2} in the pattern are treated literally": "",
    "`(?R1)` checks if a call to capture group 1 was made, which will return false the first time it is encountered because the regex engine is simply parsing capture group one.": "",
    "^ and $ match start/end of line": "",
    "$ matches only end of pattern": "",
    "3 or more of a": "",
    "A case insensitive match is performed, meaning capital letters will be matched by non-capital letters and vice versa.": "",
    "A character except: a, b or c": "",
    "A character in the range: a-z": "",
    "A character in the range: a-z or A-Z": "",
    "A character not in the range: a-z": "",
    "A common misconception is that repeating a capture group would create separate IDs for each time it matches. If that functionality is needed, one has to rely on the global (/g) flag instead. For example: {1}": "",
    "a line": "",
    "A lookbehind assertion has to be fixed width": "",
    "A named subpattern may not have a name which length exceeds 32 characters": "",
    "A non-capturing group allows you to apply quantifiers to part of your regex but does not capture/assign an ID.": "",
    "A posix character class may only appear inside a character class": "",
    "A quantifier following a lookaround serves no purpose, and can safely be removed from the regular expression": "",
    "A quantifier inside a lookbehind makes it non-fixed width": "",
    "A repeated capturing group will only capture the last iteration. Put a capturing group around the repeated group to capture all iterations or use a non-capturing group instead if you're not interested in the data": "",
    "a single character in the range between {1} {2} and {3} {4} ({5})": "",
    "A single character of: a, b or c": "",
    "A solution with a score of {1} is better than {2}% of all submissions.": "",
    "A special thanks goes out to the following individuals who helped me with the quiz questions:": "",
    "A subpattern name must be alpha numeric and may not begin with a digit": "",
    "A subpattern name must be unique": "",
    "A word boundary": "",
    "Absolute end of string": "",
    "Account": "",
    "Account Page": "",
    "acts like {1}, except that if the pattern is unanchored, the bumpalong advance is not to the next character, but to the position in the subject where {2} was encountered": "",
    "Add": "",
    "Add bold text": "",
    "Add bulleted list": "",
    "Add header": "",
    "Add italic text": "",
    "Add numbered list": "",
    "Add tag": "",
    "Add test": "",
    "Add to favorites": "",
    "All settings to control the application are located here.": "",
    "All the errors detected are listed below, from left to right, as they appear in the pattern.": "",
    "All Tokens": "",
    "Allow duplicate subpattern names": "",
    "Allow others to edit permalink": "",
    "Allows regex to match unicode characters via dotall and unicode escape sequences, as well as ES6 unicode code point escapes such as {1} which is made up of {2}.": "",
    "Also known as global mode, it instruct the engine not to stop after the first match has been found, but rather to continue until no more matches can be found.": "",
    "Alternate - match either a or b": "",
    "Alternative (acts like boolean OR)": "",
    "Always collapse left sidebar": "",
    "Always collapse right sidebar": "",
    "An alternate way to match alphabet letters. Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "An alternate way to match any letter or digit. Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "An alternator at this position effectively truncates the entire pattern, rendering any other tokens beyond this point useless": "",
    "An alternator at this position effectively truncates the group, rendering any other tokens beyond this point useless": "",
    "An empty alternative effectively makes this group optional which suggests the alternative is completely redundant": "",
    "An end quote token encountered before a start quote token": "",
    "An error occurred while fetching the resource": "",
    "An explanation of your regex will be automatically generated as you type.": "",
    "An unescaped delimiter must be escaped with a backslash ({1})": "",
    "Anchor": "",
    "Anchor to start of pattern": "",
    "Anchors": "",
    "anonymous": "",
    "Another option is enabling the x flag to allow `# comments` but it will also cause the regex engine to ignore space characters. To match space characters you have to escape them: {1}.": "",
    "Any changes to the library entry, both the expression, as well as title/description/etc, can be made at the following url: {1}": "",
    "Any character following a {1} that is not a valid meta sequence will be faulted and raise an error. {2}, for example, will cause an error, and it will not match.": "",
    "Any characters between {1} and {2}, including metacharacters, will be treated as literals.": "",
    "Any digit": "",
    "Any non-digit": "",
    "Any non-whitespace character": "",
    "Any non-word character": "",
    "Any single character": "",
    "Any text appearing in this group is ignored in the regex.": "",
    "Any Unicode sequences, linebreaks included": "",
    "Any whitespace character": "",
    "Any word can be used as a tag": "",
    "Any word character": "",
    "Are you sure you want to delete this regex?": "",
    "Are you sure you want to delete this regex? This action is non-reversible and will delete all versions of this regex.": "",
    "as few times as possible, expanding as needed": "",
    "as many times as possible, giving back as needed": "",
    "as many times as possible, without giving back": "",
    "ASCII codes 0-127": "",
    "ASCII control characters": "",
    "assert position at a word boundary: {1}": "",
    "assert position where {1} does not match": "",
    "assert that": "",
    "Assert that the Regex below does not match": "",
    "Assert that the Regex below matches": "",
    "Assertion": "",
    "asserts position at start of {1}": "",
    "asserts position at start of the string": "",
    "asserts position at the end of a line": "",
    "asserts position at the end of the previous match or the start of the string for the first match": "",
    "asserts position at the end of the string": "",
    "asserts position at the end of the string, or before the line terminator right at the end of the string (if any)": "",
    "Asserts that the given subpattern can be matched here, without consuming characters": "",
    "Atomic Group": "",
    "Atomic group (non-capturing)": "",
    "Author": "",
    "Auto-complete Brackets": "",
    "Automatic": "",
    "Available keyboard shortcuts": "",
    "Avoid using this legacy syntax for any new patterns.": "",
    "Backspace character": "",
    "Backticks can not be used in a raw string, use {1} instead": "",
    "Because you are not signed in this entry has not been tied to an account. It is recommended you sign in so that your entries are never lost and you can manage them from the account page whenever you like.": "",
    "Become a sponsor": "",
    "Become a sponsor!": "",
    "Before even attempting a match, the regex engine makes some checks, such as the length of the string. If it is not long enough to fit the pattern, it will automatically return a no match. This optimization can be disabled by using this modifier.": "",
    "Beta Sign-in": "",
    "Between 3 and 6 of a": "",
    "Beware that this will refresh the page and any unsaved progress will be lost!": "",
    "Bogus escape: this escape is not recognized in the python flavor": "",
    "Branch Reset Group": "",
    "Bug Reports & Feedback": "",
    "Bugs or suggestions go here": "",
    "By default, {1} matches any unicode newline character or sequence thereof. Its behavior can be controlled by newline convention verbs like {2} or {3}.": "",
    "Cancel": "",
    "Capture everything enclosed": "",
    "capture group {1}": "",
    "Capture Group {1} is {2} ... and so on": "",
    "Capture Group {1} is {2} and its start/end positions can be obtained via {3} and {4}": "",
    "Carriage return": "",
    "case insensitive": "",
    "Case insensitive": "",
    "Case insensitive match": "",
    "case sensitive": "",
    "Catastrophic Backtracking": "",
    "Catastrophic backtracking has been detected and the execution of your expression has been halted. To find out more what this is, please read the following article:": "",
    "Category": "",
    "causes a skip to the next innermost alternative if the rest of the pattern does not match": "",
    "Causes the regex engine to give up on the current match if it tries to backtrack past {1}'s position. This is useful when looking to cut down on backtracking at specific points in the regex. Equivalent to {2}.": "",
    "Causes the regex to exit if it tries to backtrack past {1}'s position. This is useful when looking to cut down on backtracking at specific points in the regex. Equivalent to {2}.": "",
    "causes the whole match to fail outright if the rest of the pattern does not match": "",
    "causes token to be ignored": "",
    "Change delimiter": "",
    "Character class missing closing bracket": "",
    "Character Classes": "",
    "Character range is out of order": "",
    "Character range with surrogate pairs without unicode enables results in ambiguous behavior": "",
    "Checking your answer...": "",
    "Close": "",
    "Close details": "",
    "Code Generator": "",
    "Collapse all tests": "",
    "Collapse test": "",
    "Comment": "",
    "Comment group": "",
    "Common Tokens": "",
    "Comparison string": "",
    "Complete match contents": "",
    "Conditional statement": "",
    "Consider a donation": "",
    "Contact": "",
    "contains": "",
    "Contents after match": "",
    "Contents before match": "",
    "Contents in capture group `foo`": "",
    "Contents in capture group 1": "",
    "Control": "",
    "Control character Y": "",
    "Control characters": "",
    "Control verb": "",
    "Converts all subsequent tokens to their {1} equivalence until {2} is encountered": "",
    "Converts metacharacters to literal characters, and also allows literal matching of the regex delimiter in use, like `/`.": "",
    "Converts the subsequent token to their {1} equivalence": "",
    "Copied!": "",
    "Copy to clipboard": "",
    "Criteria": "",
    "Current score: {1}": "",
    "Dark": "",
    "Data": "",
    "Decimal digits": "",
    "Decrease speed": "",
    "Decrease step range": "",
    "Default code generator language": "",
    "Default flavor": "",
    "Delete": "",
    "Delete library entry": "",
    "Delete permalink": "",
    "Delete Regex": "",
    "Delete regular expression": "",
    "Delimiters": "",
    "Description": "",
    "Description of regular expression": "",
    "Detailed match information will be displayed here automatically.": "",
    "Disallow duplicate subpattern names": "",
    "Disallow meaningless escapes": "",
    "Disallow others to edit permalink": "",
    "Disallows backtracking past {1}'s position, and gives up matching the current alternation if there's a failure. If instead {1} is used outside of an alternation, it will act like {3}. Equivalent to {2}.": "",
    "Discussion": "",
    "does match": "",
    "Does not allow the capture group ID to be incremented for all enclosed capture groups.": "",
    "does not match": "",
    "Don't return after first match": "",
    "Donate": "",
    "Dot matches newline": "",
    "Downvote": "",
    "Due to a bug in PCRE creating ranges with an escaped literal is unsafe. To avoid this, simply use the literal representation instead": "",
    "Duplicate group names": "",
    "Duplicate/reset subpattern group number": "",
    "Edit": "",
    "Edit account entry": "",
    "Edit personal title": "",
    "Edit test": "",
    "Edit title and tags": "",
    "Editor": "",
    "Else match the following regex": "",
    "empty character class — matches {1}": "",
    "empty string": "",
    "Enable or disable the syntax highlighting of your regular expression in the editor": "",
    "Enable unicode support": "",
    "End of quoted literals": "",
    "End of string": "",
    "End of word": "",
    "ends with": "",
    "Engine Error": "",
    "Enjoy and I hope you learn something!": "",
    "Ensures that the given pattern will match, ending at the current position in the expression. The pattern be of variable width. Does not consume any characters.": "",
    "Ensures that the given pattern will match, ending at the current position in the expression. The pattern must have a fixed width. Does not consume any characters.": "",
    "Ensures that the given pattern would not match and end at the current position in the expression. The pattern be of variable width. Does not consume characters.": "",
    "Ensures that the given pattern would not match and end at the current position in the expression. The pattern must have a fixed width. Does not consume characters.": "",
    "Enter your regex and hit submit to see the result.": "",
    "equal to {1}": "",
    "equals": "",
    "Equivalent to {1}": "",
    "Equivalent to {1}.": "",
    "Evaluate the condition below and proceed accordingly": "",
    "Exactly 3 of a": "",
    "Expand all tests": "",
    "Expand test": "",
    "Expected group {1} to contain `{2}` but did not": "",
    "Expected group {1} to end with `{2}` but was instead `{3}`": "",
    "Expected group {1} to equal `{2}` but was instead `{3}`": "",
    "Expected group {1} to start with `{2}` but was instead `{3}`": "",
    "Expected regex to match, but did not.": "",
    "Expected regex to not match, but did.": "",
    "Explanation": "",
    "Export Matches": "",
    "Export Method": "",
    "eXtra": "",
    "Favorite Regex": "",
    "Fewest Points": "",
    "Filter by Flavor": "",
    "Flags/Modifiers": "",
    "Flavor": "",
    "Follow me on twitter!": "",
    "For a full regex reference for {1}, please visit:": "",
    "For example, repeating 1-3 digits and a period 3 times can be done like this: {1}": "",
    "Force a matching failure at a specific point in the regex. Equivalent to {1}, and a synonym of {2}.": "",
    "Form-feed": "",
    "Full match": "",
    "full match": "",
    "Full Search Result": "",
    "Function": "",
    "General": "",
    "General Tokens": "",
    "Generated Code": "",
    "Github": "",
    "given the string": "",
    "Global": "",
    "Global pattern flags": "",
    "Go to beginning": "",
    "Go to end": "",
    "Go to the beginning": "",
    "Go to the end": "",
    "Golang/RE2, Python, and Javascript consider {1} to be just vertical tab (ascii {2}).": "",
    "Golang/RE2, Python, and Javascript equivalent is {1}.": "",
    "Google": "",
    "greedy": "",
    "Greedy quantifier": "",
    "Group": "",
    "group {1}": "",
    "Group {1}": "",
    "Group {1} found at {2}": "",
    "Group {1} no longer exists in the pattern or did not participate in the match": "",
    "Group {1} was not expected to participate in the match but did anyway": "",
    "Group Constructs": "",
    "group did not participate in match": "",
    "Groups with the same index must either have the same name or both be non-named groups": "",
    "Headers": "",
    "Here comes a {1} tab character.": "",
    "Hex character YY": "",
    "Hex character YYYY": "",
    "Hexadecimal digits": "",
    "Hexadecimal replacement values": "",
    "Highlight Syntax": "",
    "Horizontal whitespace character": "",
    "I recommend you launch the debugger in the menu to the left and analyze the data to find out the cause.": "",
    "If capturing group 1 returned a match, the pattern before the alternate {1} is matched. Otherwise, the pattern after the alternate {1} is amtched.": "",
    "If Clause": "",
    "If condition is met, match the following regex": "",
    "If left to automatic, the code generator will mirror the currently selected flavor in the editor": "",
    "If recursion of the whole pattern is successful, do something {1} otherwise do this.": "",
    "If the lookahead succeeds, matches the pattern before the vertical bar. Otherwise, matches the pattern after the vertical bar. The lookaround can be negative also. Global flag breaks conditionals.": "",
    "If the lookbehind succeeds, match the pattern before the vertical bar. Otherwise, matches the pattern after the vertical bar. The lookaround can be negative. Global flag, 'g', breaks conditionals.": "",
    "If this token is inside a capturing group, only that capturing group is ended successfully at that particular location, while the parent pattern continues to execute.": "",
    "If you are working on very large and complex expressions, turning this option off will yield improved performance": "",
    "Ignore whitespace": "",
    "Ignore whitespace / verbose": "",
    "In PCRE a recursion test {1}, group name {2}, or a relative position {3} can be used as the conditional. Global flag breaks conditionals as the engine does a second pass over an already matched/consumed string.": "",
    "In the example below, the first alternate matched \"a\", and the second one matched \"bc\", however once it bumped into \"X\" none of the alternatives resulted in a match. Therefore the engine cannot return the next \"a\" as a match because \"X\" is not the last location where a match occurred.": "",
    "In this case `(?(R&sub1)...|...)` checks if a call to `sub1` has been made. The first time the recursive conditional is parsed, the engine is in the process of matching what `sub1` requires, but it isn't because of a callback to `sub1`.": "",
    "Include full match in exported data": "",
    "Include non-participating groups in match result": "",
    "include the latest version of the regex crate in your Cargo.toml": "",
    "Incomplete group structure": "",
    "Increase speed": "",
    "Increase step range": "",
    "Inline modifiers": "",
    "Insert a carriage return character.": "",
    "Insert a form-feed character.": "",
    "Insert a newline character.": "",
    "Insert a personal title": "",
    "Insert a tab character.": "",
    "Insert code snippet": "",
    "insert comparison string": "",
    "Insert link": "",
    "Insert quote": "",
    "insert test description": "",
    "insert test string": "",
    "insert your regular expression here": "",
    "insert your replacement value here": "",
    "insert your test string here": "",
    "inserts the matched substring": "",
    "inserts the portion of the string that follows the matched substring": "",
    "inserts the portion of the string that precedes the matched substring": "",
    "Internal engine error: {1}": "",
    "Introduction": "",
    "Invalid control character": "",
    "Invalid placement of hyphen; there may only be one inside the group": "",
    "Invalid unicode escape": "",
    "is null": "",
    "Isolates part of the full match to be later referred to by ID within the regex or the matches array. IDs start at 1.": "",
    "It might be a good idea to open another tab to fiddle with the expressions, and utilize the very powerful unit test feature located in the regex editor.": "",
    "Jump {1} steps backwards": "",
    "Jump {1} steps forward": "",
    "Keep in mind that Python 3 is going to treat your whole script as unicode by default, therefore using this flag would be redundant. See the {1} flag to limit matches to ASCII characters only. Python 2 requires this flag to turn on unicode support.": "",
    "Keyboard Shortcuts": "",
    "Language": "",
    "lazy": "",
    "Lazy quantifier": "",
    "Letters": "",
    "Letters and digits": "",
    "Library entries": "",
    "Library Entry": "",
    "Light": "",
    "Like regex101? Support it by donating!": "",
    "Limits the number of recursions the engine is allowed to make to `d` times. This user set limit cannot be increased past the compile time value or the default, however it can be restricted.": "",
    "Limits the number of times the regex engine is allowed to call `match()` to `x` times. This user set limit cannot be increased past the compile time value or the default, however it can be restricted.": "",
    "Line break modifier": "",
    "Line terminator(s) are {1} {2}": "",
    "Lines are delimited by {1} {2}": "",
    "Link to regular expression": "",
    "literally": "",
    "Live Help": "",
    "Loading changelog...": "",
    "Loading...": "",
    "Localized inline modifiers": "",
    "Lookahead conditional": "",
    "Lookbehind conditional": "",
    "lowercase": "",
    "Lowercase letters": "",
    "Lowercase Transformation": "",
    "Make escape sequences perform ASCII-only matching": "",
    "Make permalink private": "",
    "Make permalink public": "",
    "Make quantifiers lazy": "",
    "Make regex perform ASCII-only matching instead of full Unicode matching. Applies to [a-z] ranges and escape sequences.": "",
    "Makes any character literal": "",
    "Makes it so that any unicode newline character or sequence thereof counts as a line break.": "",
    "Makes it so that either a carriage return character or a line feed character, or the two in sequence are considered a line break.": "",
    "Makes it so that only a carriage return character followed by a line feed character is considered a line break. Common in Windows documents.": "",
    "Makes it so that only a carriage return character is considered a line break.": "",
    "Makes it so that only a line feed character is considered a line break. Common in UNIX documents.": "",
    "marker verb whose main purpose is to track how a match was arrived at": "",
    "Match": "",
    "Match {1}": "",
    "Match {1} failed in {2} step(s)": "",
    "Match {1} found in {2} step(s)": "",
    "Match {1} halted after {2} step(s)": "",
    "Match {1} was found at {2}": "",
    "Match a single character not present in the list below": "",
    "Match a single character not present in the set": "",
    "Match a single character present in the list below": "",
    "Match a single character present in the set": "",
    "match any non-word character in any script (equal to {1})": "",
    "match any word character in any script (equal to {1})": "",
    "Match anything but a newline": "",
    "Match everything enclosed": "",
    "Match Information": "",
    "Match nth subpattern": "",
    "Match one data unit": "",
    "Match previously-named capture group `letter`": "",
    "Match Step {1}": "",
    "Match Steps": "",
    "Match subpattern `name`": "",
    "Match subpattern number #": "",
    "Match text the nth relative previous subpattern matched": "",
    "match the remainder of the pattern with the following effective flags: {1}": "",
    "Match was found at {1}": "",
    "Match with full unicode": "",
    "matches a alphabetic character {1}": "",
    "matches a alphanumeric character {1}": "",
    "matches a alphanumeric character or {1} {2} (also written as {3})": "",
    "matches a backspace character {1}": "",
    "matches a carriage return {1}": "",
    "Matches a carriage return, unicode character U+2185.": "",
    "matches a character intended to be combined with another character (e.g. accents, umlauts, enclosing boxes, etc.)": "",
    "matches a character intended to be combined with another character that takes up extra space (vowel signs in many Eastern languages)": "",
    "matches a character intended to be combined with another character without taking up extra space (e.g. accents, umlauts, etc.)": "",
    "matches a character that encloses the character is is combined with (circle, square, keycap, etc.)": "",
    "matches a character with {1} value {2} through {3}": "",
    "matches a combining character (mark) as a full character on its own": "",
    "matches a control character {1}": "",
    "matches a digit (equal to {1})": "",
    "matches a digit {1} (also written as {2})": "",
    "matches a digit zero through nine in any script except ideographic scripts": "",
    "matches a digit zero through nine in any script except ideographic scripts (equal to {1})": "",
    "matches a form-feed character {1}": "",
    "matches a hexadecimal digit {1}": "",
    "matches a letter or ideograph that does not have lowercase and uppercase variants": "",
    "matches a letter that appears at the start of a word when only the first letter of the word is capitalized": "",
    "matches a letter that exists in lowercase and uppercase variants (combination of {1}, {2} and {3})": "",
    "matches a line separator character {1}": "",
    "matches a line-feed (newline) character {1}": "",
    "matches a lowercase letter {1}": "",
    "matches a lowercase letter that has an uppercase variant": "",
    "Matches a newline character": "",
    "Matches a null character, most often visually represented in unicode using U+2400.": "",
    "matches a number that looks like a letter, such as a Roman numeral": "",
    "matches a paragraph separator character {1}": "",
    "matches a punctuation character {1}": "",
    "matches a punctuation character such as an underscore that connects words": "",
    "matches a single character in the list": "",
    "matches a special character that is used like a letter": "",
    "matches a superscript or subscript digit, or a number that is not a digit (excluding numbers from ideographic scripts)": "",
    "matches a tab character {1}": "",
    "Matches a tab character. Historically, tab stops happen every 8 characters.": "",
    "Matches a unicode character outside of the given property.": "",
    "Matches a unicode character that doesn't have any of the given properties.": "",
    "Matches a unicode character with the given group of properties or categories:": "",
    "Matches a unicode character with the given property:": "",
    "matches a uppercase letter {1}": "",
    "matches a vertical tab character": "",
    "matches a visible character {1}": "",
    "matches a visible character or the space character {1}": "",
    "matches a whitespace character that is invisible, but does take up space": "",
    "matches a whitespace character, including a line break {1}": "",
    "matches a whitespace character, including a line break {1} (also written as {2})": "",
    "Matches an `a` character or nothing.": "",
    "matches an ASCII {1} or Latin-1 {2} control character": "",
    "matches an uppercase letter that has a lowercase variant": "",
    "matches any character {1}": "",
    "Matches any character except for an a, b or c": "",
    "Matches any character in the valid ASCII range. Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches any character other than newline (or including line terminators with the {1} flag)": "",
    "Matches any character that is not a newline, the opposite of {1}. Not affected by the single line (/s) flag.": "",
    "Matches any character that is not horizontal whitespace {1}.": "",
    "matches any character that's not a digit (equal to {1})": "",
    "matches any character that's not a horizontal whitespace character": "",
    "matches any character that's not a vertical whitespace character": "",
    "matches any character, including newline": "",
    "matches any character, including unicode {1}": "",
    "Matches any characters between a and z, including a and z.": "",
    "Matches any characters between a-z or A-Z. You can combine as much as you please.": "",
    "Matches any characters except those in the range a-z.": "",
    "matches any characters in the {1} {2}": "",
    "matches any characters that {1} does not": "",
    "matches any code point reserved for private use": "",
    "matches any code point to which no character has been assigned": "",
    "matches any currency sign": "",
    "Matches any decimal digit. Equivalent to {1}.": "",
    "matches any horizontal whitespace character (equal to {1})": "",
    "matches any kind of closing bracket": "",
    "matches any kind of closing quote": "",
    "matches any kind of hyphen or dash": "",
    "matches any kind of invisible character (equal to {1})": "",
    "matches any kind of letter from any language": "",
    "matches any kind of numeric character in any script": "",
    "matches any kind of opening bracket": "",
    "matches any kind of opening quote": "",
    "matches any kind of punctuation character": "",
    "matches any kind of punctuation character that is not a dash, bracket, quote or connector": "",
    "matches any kind of visible character (equal to {1})": "",
    "matches any kind of whitespace or invisible separator": "",
    "Matches any letter, digit or underscore. Equivalent to {1}.": "",
    "matches any math symbols, currency signs, dingbats, box-drawing characters, etc": "",
    "matches any mathematical symbol": "",
    "matches any non-newline character": "",
    "matches any non-numeric character in any script (equal to {1})": "",
    "matches any non-whitespace character (equal to {1})": "",
    "matches any non-word character (equal to {1})": "",
    "matches any number of Unicode characters that form an extended Unicode sequence": "",
    "Matches any space, tab or newline character.": "",
    "matches any Unicode newline sequence; can be modified using verbs": "",
    "Matches any Unicode newline sequence. Equivalent to (?>\\r\\n|\\n|\\x0b|\\f|\\r|\\x85).": "",
    "Matches any valid Unicode sequence, including line breaks. Equivalent to {1}.": "",
    "matches any vertical whitespace character": "",
    "matches any whitespace character (equal to {1})": "",
    "matches any word character (equal to {1})": "",
    "Matches anything not matched by {1}.": "",
    "Matches anything other than a decimal/digit.": "",
    "Matches anything other than a letter, digit or underscore. Equivalent to {1}": "",
    "Matches anything other than a space, tab or newline.": "",
    "Matches as few characters as possible.": "",
    "Matches as many characters as possible; backtracking can't reduce the number of characters matched. Because it is greedy, it will match all the way to the last digit, leaving nothing else for the {1} to match. Without backtracking, this regex fails to produce a match.": "",
    "Matches as many characters as possible.": "",
    "Matches ASCII characters typically associated with Control+A through Control+Z: \\x01 through \\x1A.": "",
    "Matches at least 3 consecutive `a` characters.": "",
    "Matches between 3 and 6 (inclusive) consecutive `a` characters.": "",
    "Matches characters that are not whitespace, letters or numbers. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches characters that are often used to control text presentation, including newlines, null characters, tabs and the escape character. Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches decimal digits. Equivalent to {1} or {2}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches either an a, b or c character": "",
    "Matches either what is before the {1} or what is after it - in this case `a` or `b`.": "",
    "Matches end of word (POSIX syntax), equivalent to {1}": "",
    "matches esc {1}": "",
    "Matches exactly 3 consecutive `a` characters.": "",
    "Matches exactly one data unit of input. Can match individual bytes in UTF-8 mode, leading to undefined behaviour if a search starts inside a character.": "",
    "Matches hexadecimal digits, case insensitive. Equivalent to {1}.": "",
    "matches invisible control characters and unused code points": "",
    "matches invisible formatting indicator": "",
    "Matches letters, numbers and underscores. Equivalent to {1} or {2}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches lowercase letters. Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "matches one data unit, even in UTF mode (best avoided)": "",
    "matches one half of a surrogate pair in {1} encoding": "",
    "Matches one or more consecutive `a` characters.": "",
    "Matches printable characters, part of the basic latin set, such as letters and spaces, without including control characters. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches printable, non-whitespace, non-control characters only. Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches spaces and tabs (but not newlines). Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches spaces, tabs, non-breaking/mathematical/ideographic spaces, and so on. Works with Unicode.": "",
    "Matches start of word (POSIX syntax), equivalent to {1}": "",
    "Matches text the nth group matched and captured. `n` represents the capture group number and can positionally refer to past capture groups as well.": "",
    "Matches the 16-bit character with the given hex value.": "",
    "Matches the 8-bit character with the given hex value.": "",
    "Matches the 8-bit character with the given octal value.": "",
    "Matches the backspace control character. {1} stands for `word boundary` when outside of a character class {2}.": "",
    "matches the bell character {1}": "",
    "matches the character": "",
    "matches the character {1} with index {2} ({3} or {4}) literally ({5})": "",
    "matches the characters": "",
    "matches the control sequence {1} {2}": "",
    "Matches the end of a string only. Unlike {1}, this is not affected by multiline mode, and, in contrast to {2}, will not match before a trailing newline at the end of a string.": "",
    "Matches the end of a string only. Unlike {1}, this is not affected by multiline mode.": "",
    "Matches the end of a string without consuming any characters. If multiline mode is used, this will also match immediately before a newline character.": "",
    "Matches the longest possible substring in the group and doesn't allow later backtracking to reevaluate the group. It is not a capturing group.": "",
    "matches the negation of {1}": "",
    "Matches the same text a capture group called `name` matched and captured. Alternate notations are {1} and {2}. Valid for .NET.": "",
    "matches the same text as most recently matched by the {1} capturing group": "",
    "matches the same text as most recently matched by the capturing group named {1}": "",
    "matches the same text as most recently matched by the entire pattern": "",
    "Matches the same text capture group called `letter` matched and captured.": "",
    "Matches the same text matched and captured by a previously named capture group.": "",
    "Matches the same text matched by a previously named capture group.": "",
    "Matches the same text the nth group prior to {1} matched and captured.": "",
    "Matches the start of a string only. Unlike {1}, this is not affected by multiline mode.": "",
    "Matches the start of a string without consuming any characters. If {1} multiline mode is used, this will also match immediately after a newline character.": "",
    "Matches the text captured by the nth group. n can contain more than one digit, if necessary.": "",
    "Matches the unicode character with the given hex value.": "",
    "Matches unicode vertical whitespace, considered a character class by the PCRE engine: {1}.": "",
    "Matches uppercase letters. Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "matches various symbols that are not math symbols, currency signs, or combining characters": "",
    "Matches whitespace characters. Equivalent to {1}. The double square brackets is not a typo, POSIX notation demands it.": "",
    "Matches zero or more consecutive `a` characters.": "",
    "Matches, without consuming any characters, at the position between two characters matched by {1}.": "",
    "Matches, without consuming any characters, immediately between a character matched by {1} and a character not matched by {1} (in either order). It cannot be used to separate non words from words.": "",
    "Max Execution Time": "",
    "May only be used to define functions. No matching is done in this group.": "",
    "meaningless quantifier": "",
    "Meta Sequences": "",
    "Most Points": "",
    "Most Recent": "",
    "Move down": "",
    "Move up": "",
    "Multiline": "",
    "My Expressions": "",
    "My Favorites": "",
    "My Library Entries": "",
    "My Regular Expressions": "",
    "My rendition of it is incomplete, and there are many improvements to be made. If you do have any feedback, please post it in the github issues and I will take a look at it.": "",
    "Name or other identifier of the author": "",
    "Named Capture Group {1}": "",
    "Named capture groups can be called via {1}": "",
    "Named Capturing Group": "",
    "Negation of \\h": "",
    "Negation of \\p": "",
    "Negation of \\pX": "",
    "Negation of \\v": "",
    "Negative Lookahead": "",
    "Negative Lookbehind": "",
    "Newline": "",
    "Next page": "",
    "Next question": "",
    "no description available": "",
    "No hex code was specified": "",
    "No Internet Connection": "",
    "No Match": "",
    "No match groups were extracted.": "",
    "No result": "",
    "Non-atomic Positive Lookahead": "",
    "Non-atomic Positive Lookbehind": "",
    "Non-capturing group": "",
    "Non-capturing Group. Matches the regex below with the following effective flags: {1}": "",
    "Non-word boundary": "",
    "Note that {1} is wrapped in a superfluous capture group to help visually identify its match in the example string.": "",
    "Note that this feature is not yet supported on all browsers; use at your own discretion!": "",
    "Note: for Python 2.7 compatibility, use ur{1}{2} to prefix the regex and u\"\" to prefix the test string and substitution.": "",
    "Nothing to preview": "",
    "Null character": "",
    "Octal character ddd": "",
    "Octal Character Table": "",
    "Ok": "",
    "Once `(?1)` is called, `(?(R1)true|false)` will return true since capture group 1 was called, and will match `ction`": "",
    "Once we actually call `sub1` the conditional will return true, at which point `ction` matches.": "",
    "one": "",
    "One or more of a": "",
    "Open regex in editor": "",
    "optional": "",
    "or": "",
    "Order By": "",
    "Pattern Backtrack Indicator": "",
    "Pattern Error": "",
    "Pattern may not end with a trailing backslash": "",
    "Pattern modifier": "",
    "Pattern strings will be treated as UTF-16, which means that unicode characters will also be included in {1} ranges, and in escape sequences like {2}.": "",
    "Pause": "",
    "PCRE equivalent is {1}.": "",
    "Plain Text": "",
    "Play": "",
    "Please enable JavaScript to use this web application.": "",
    "Please keep in mind that these code samples are automatically generated and are not guaranteed to work. If you find any syntax errors, feel free to submit a bug report.": "",
    "Please note that the quiz is still under development and is to be considered in BETA. It is subject to change, but I'm trying to avoid as many drastic changes as possible. I apologize for any inconvenience this may cause you.": "",
    "Please note this feature is experimental in JavaScript and might not be supported by your browser.": "",
    "Please wait while the app is loading...": "",
    "Please wait while your expression is being debugged...": "",
    "Please wait while your request is being processed...": "",
    "pos: {1}-{2}": "",
    "Positive Lookahead": "",
    "Positive Lookbehind": "",
    "POSIX Word Boundaries must be the only item inside a character class": "",
    "possessive": "",
    "Possessive quantifier": "",
    "Pre-define patterns before using them": "",
    "Press {1} to copy": "",
    "Preview": "",
    "Previous page": "",
    "Print the match result": "",
    "Print the result of the substitution": "",
    "Proceed matching from where previous match ended only": "",
    "Processing...": "",
    "Quantifier": "",
    "Quantifier range is too large": "",
    "Quantifiers": "",
    "Quick Reference": "",
    "Quiz Submission Score": "",
    "Quote; treat as literals": "",
    "Quoted Literals": "",
    "Quoted Literals: match the string enclosed in the quote literally": "",
    "Recurse entire pattern": "",
    "Recurse first relative subpattern": "",
    "Recurse first subpattern": "",
    "Recurse named capture group `letter`": "",
    "Recurse nth capture group": "",
    "Recurse nth capture group ahead of the current position of {1}. For example {2} is the second previous capture group.": "",
    "Recurse nth capture group ahead of the current position of {1}. For example, {2} is the second upcoming capture group.": "",
    "Recurse nth capture group.": "",
    "Recurse nth capture group. `n` can be positional as well. For example, {1} stands for previous capture group, while {2} would be the third capture group. Equivalent to {3}.": "",
    "Recurse nth capture group. `n` can be positional as well. For example, {1} stands for the previous capture group, while {2} would be the third next capture group. Equivalent to {3}": "",
    "Recurse nth relative upcoming subpattern": "",
    "Recurse subpattern `name`": "",
    "Recurse subpattern called `name`": "",
    "Recurse the capture group called \"letter\". This is an alternative notation for \\g'letter'": "",
    "Recurse the capture group called `letter`.": "",
    "Recurse the first capture group following the current position in the expression. {1} is the second capture group, {2} is the capture group immediately preceding the current position.": "",
    "recurses the {1} subpattern": "",
    "recurses the entire pattern": "",
    "recurses the subpattern named {1}": "",
    "Recursive Conditional statement": "",
    "Recursively match the entire expression. Equivalent to {1} or {2}.": "",
    "Recursively match the first capture group.": "",
    "Recursively matches the given capture group by name. It does not require that the capture group be defined beforehand.": "",
    "Recursively matches the given named subpattern or capture group.": "",
    "regex": "",
    "Regex Debugger": "",
    "Regex Editor": "",
    "Regex engine modifier": "",
    "Regex Flags": "",
    "Regex Library": "",
    "Regex Quiz": "",
    "RegEx Score (lower is better)": "",
    "Regex Versions": "",
    "Regex will continue parsing the string keeping in mind the last match location. If the next match is not located directly after the last, this next match is discarded.": "",
    "Regex101 only supports inline modifiers to be placed at the start of the regex for python (which is also best practice)": "",
    "Regular Expression": "",
    "Relevance": "",
    "Remove from favorites": "",
    "Replaces the text conditionally depending on if the {1} matched": "",
    "Reset match": "",
    "resets the starting point of the reported match. Any previously consumed characters are no longer included in the final match": "",
    "Restrict matches to ASCII only": "",
    "Result": "",
    "result will be a String with the substituted value": "",
    "result will be a tuple containing the start and end indices for the first match in the string": "",
    "result will be an iterator over tuples containing the start and end indices for each match in the string": "",
    "Returns a string with the full match result. `0` can be replaced with any desired capture group ID to return that part of the match instead.": "",
    "Run test": "",
    "Run tests": "",
    "Save": "",
    "Save & Share": "",
    "Save Regex": "",
    "Save Regular Expression": "",
    "Saved settings": "",
    "script": "",
    "script extension": "",
    "Search library": "",
    "Search reference": "",
    "Seek one step backwards": "",
    "Seek one step forward": "",
    "Select Regex Version": "",
    "Select the flavor you want to use when the site loads. Note: a saved entry's flavor will override this": "",
    "Send me an email": "",
    "Set Regex Options": "",
    "Sets the convention for newline matching to {1}, {2}, or {3} for things like the {4} metacharacter.": "",
    "Sets the given position in the regex as the new start of the match. Nothing preceding {1} will be returned as part of the full match.": "",
    "sets the property mode to {1}": "",
    "sets the property mode to Unicode": "",
    "Settings": "",
    "Shortcut": "",
    "shorthand for {1}": "",
    "Show how many steps a regular expression takes to evaluate": "",
    "Show informative and helpful tooltips when hovering tokens in the regex editor": "",
    "Show Line Numbers in Regex Editor": "",
    "Show Line Numbers in Test String Editor and Substitution Result": "",
    "Show Sidebar": "",
    "Show tooltips": "",
    "Show warning popup when trying to leave site with unsaved data": "",
    "Sign In": "",
    "Sign in with one of the providers below": "",
    "Sign out": "",
    "Signing in allows you to add favorites as well as manage, make private, and delete your expressions.": "",
    "Single line": "",
    "Space or tab only": "",
    "specifies a newline convention: {1}, {2} or {3}": "",
    "specifies a newline convention: {1}, {2} or {3} only": "",
    "specifies a newline convention: {1}, followed by {2}": "",
    "specifies a newline convention: all unicode newline sequences {1}": "",
    "specifies a newline convention: any Unicode newline sequence": "",
    "specifies a newline convention: carriage return": "",
    "specifies a newline convention: line-feed": "",
    "Sponsor": "",
    "Start of match": "",
    "Start of string": "",
    "Start of word": "",
    "Starting at the current position in the expression, ensures that the given pattern will not match. Does not consume characters.": "",
    "starts with": "",
    "step": "",
    "steps": "",
    "Sticky - searches in strings only from the index of the last match": "",
    "Style": "",
    "Styling with Markdown is supported": "",
    "Submit": "",
    "Submit Workspace to Regex Library": "",
    "Submitted by": "",
    "subpattern {1}": "",
    "Subpattern definition construct": "",
    "Subpatterns declared within each alternative of this construct will start over from the same index": "",
    "Substitution": "",
    "Substitution result": "",
    "Success": "",
    "suppresses the start-of-match optimizations that are otherwise run by Perl": "",
    "Surrogate values are disallowed in Unicode mode": "",
    "Tab": "",
    "Tags": "",
    "Target": "",
    "Task {1}": "",
    "Task Statistics": "",
    "Tasks": "",
    "Terminate any Transformation": "",
    "Terminates any of the previous {1} (uppercase) or {2} (lowercase) transformations. This is a feature only available on regex101.com.": "",
    "Terminates any previous text transformation (initiated with either \\U or \\L)": "",
    "Test passed": "",
    "Test String": "",
    "Test String Backtrack Indicator": "",
    "Thank you for your contribution": "",
    "The {1} and {2} anchors now match at the beginning/end of each line respectively, instead of beginning/end of the entire string or input.": "",
    "the above tag defines encoding for this document and is for Python 2.x compatibility": "",
    "The assertion determines how you want to validate the target.": "",
    "The character offset is too large": "",
    "The condition is invalid (you may be referencing a non-existent subpattern or group)": "",
    "The DEFINE group is completely ignored by regex. It gets treated as a var name=\"value\", whereas you can recall the specific pattern for use via its name. Multiple patterns can be defined in the same DEFINE group.": "",
    "The engine will per default do lazy matching, instead of greedy. This reverses the meaning of {1}, which will now make the previous quantifier greedy.": "",
    "The entry has automatically been added to your account which means you can at any time delete this entry, make it private and much much more.": "",
    "The escape sequence to match backspace is not supported in the selected flavor": "",
    "The goal is to provide a fun way to learn how to use regular expressions with real life tasks, and at the same time try to guide you to learn useful constructs and how the internals of the regex engine works.": "",
    "The internal recursion limit was reached.": "",
    "The match was halted because the offset does not point to the beginning of a valid UTF-16 character.": "",
    "The match was halted because your expression contains a recursive loop. This means either that the whole pattern, or a subpattern, has been called recursively for the second time at the same position in the subject string.": "",
    "The number following the backslash is too large": "",
    "The pattern is forced to become anchored at the start of the search or at the position of the last successful match, equal to a {1}.": "",
    "The PCRE regex engine automatically applies some internal optimizations to regexes to avoid unnecessary backtracking. This modifier will disable that behavior, and thus the engine will backtrack until the previously matching instruction fails to do so.": "",
    "The posix class is unknown/invalid": "",
    "The preceding token is not quantifiable": "",
    "The quantifier range is out of order": "",
    "The quiz will utilize the PCRE regex engine, but many of the skills you learn will be transferable to other flavors.": "",
    "The range is invalid because either the left or right token is erroneous": "",
    "The range is invalid because the rightmost token is not rangeable": "",
    "The regex debugger returned no data for the input you provided.": "",
    "The regex debugger was unable to debug your pattern due to an error.": "",
    "The regex did not match the subject string.": "",
    "The result can be accessed through the `m`-variable.": "",
    "The result of the substitution is": "",
    "the string": "",
    "The substituted value will be contained in the result variable": "",
    "The target specifies what it is you want to test. This determines in turn which assertions are possible": "",
    "The tasks will be unlocked one by one. When you finish task 1, task 2 will be unlocked, and so on.": "",
    "The tasks will get progressively harder, and you will receive less and less hand-holding the further you progress.": "",
    "The token is incomplete": "",
    "The value specified is too large": "",
    "Theme": "",
    "There are no unit tests yet; add some!": "",
    "There are too many alternatives within the parent structure": "",
    "There does not seem to be anything here": "",
    "There was a problem trying to fetch the library data. Please try again later.": "",
    "There was a problem when trying to fetch the details for this entry. Please try again later.": "",
    "There was a problem while trying to submit your regex to the library. Please try again later.": "",
    "There was an error fetching the quiz data. Please try again later.": "",
    "There was an error querying the server, please try again later:": "",
    "There was an error trying to save your regex. Please try again later.": "",
    "There was an error while fetching your account data. Please try again later.": "",
    "These flag modifiers act on the enclosed expression only. Equivalent to {1}": "",
    "These flag modifiers act on the whole expression. You can also unset flags using a minus sign: {1}, and can combine setting and unsetting flags. {2} would set the single line flag and unset case insensitive.": "",
    "They are automatically saved as you change them and will be automatically loaded every time.": "",
    "This allows regex to accept duplicate pattern names, however each capture group still has its own ID. Thus the two capture groups produce their own match instead of a single combined one.": "",
    "This allows regex to treat the string as UTF-16, specifically.": "",
    "This allows regex to treat the string as UTF-32, specifically.": "",
    "This allows regex to treat the string as UTF-8, specifically.": "",
    "This allows regex to treat the string as UTF, be it 8, 16, or 32.": "",
    "This capturing group can be referred to using the given name instead of a number.": "",
    "This capturing group can be referred to using the given name instead of a number. Alternative notation for (?'name'...) and (?P<name>...).": "",
    "This capturing group can be referred to using the given name instead of a number. Alternative notation for (?<name>...) and (?'name'...) when using a PCRE flavor.": "",
    "This capturing group can be referred to using the given name instead of a number. Alternative notation for {1} or {2}.": "",
    "This causes the regex to end successfully, skipping the rest of the pattern.": "",
    "This enables the dot metacharacter {1} to also match newlines. The whole string is treated as a single line input.": "",
    "This flag does not exist in Python2, as by default your script is parsed in ascii mode. In Python3 this will behave as described.": "",
    "This flag tells the engine to ignore all whitespace and allow for comments in the regex; also called verbose. Comments are indicated by a starting \"#\"-character. If you need to include a space character in your regex, it must now be escaped '\\ '.": "",
    "This generator only supports substitution. Please update your regular expression accordingly": "",
    "This group does not allow any backtracking to occur": "",
    "This hyphen is treated literally, which might be confusing for others. Consider escaping it or placing at the start or end of the class!": "",
    "This is an alternate syntax for {1} or {2}.": "",
    "This is necessary to avoid infinite loops with zero-width matches": "",
    "This may be useful in order to avoid ambiguity with octal characters.": "",
    "This means that your pattern did match but there were no capturing groups that matched anything in the subject string.": "",
    "This notation is useful in avoiding ambiguity with octal characters, or when a literal number needs to be matched immediately after a {1} reference in the regex.": "",
    "This POSIX equivalent of the \"\\b\" word boundary is interpreted as": "",
    "This POSIX equivalent of the {1} (word boundary) is interpreted as {2}": "",
    "This quiz used to be featured on this website many years ago, but was abandoned due to the vast amount of work to keep it updated. I have finally found the time to resurrect it, and ported it to the new website. It is based on the original quiz created by msmo many, many, years ago.": "",
    "This script is unknown/invalid": "",
    "This sets the convention for newline matching to any unicode newline character or sequence thereof, for things like the {1} metacharacter.": "",
    "This setting adjusts the site-wide theme": "",
    "This setting affects how long the matcher will try to match your regex before it decides to give up": "",
    "This setting determines whether groups in your regex, which did not match anything in the subject string, should be included in the results or not": "",
    "This token can not be used in a lookbehind as it makes it non-fixed width": "",
    "This token does nothing without a corresponding open quote tag (\\Q). If you meant to match a literal `E`, remove the backslash": "",
    "This token has no special meaning and has thus been rendered erroneous": "",
    "This token is not supported in the selected flavor": "",
    "This token is not valid under strict mode, and may cause certain browsers to throw errors. If you need to reference this subpattern, use the {1} syntax, otherwise use the token literally.": "",
    "This token must be escaped when the {1} flag is enabled unless they form a valid quantifier": "",
    "This token references a non-existent or invalid subpattern": "",
    "this verb causes the match to end successfully, skipping the remainder of the pattern": "",
    "this verb causes the match to fail at the current starting position in the subject if the rest of the pattern does not match": "",
    "this verb disables the internal `auto-possessification` optimization in PCRE": "",
    "This verb does not allow regex to continue parsing after a matching failure, even if there are other matching strings ahead, and regardless of how many successful matches are before the failure.": "",
    "This verb is unknown or invalid": "",
    "This verb must be placed at the start of the regex": "",
    "this verb sets the match limit (max iterations) for the pattern": "",
    "this verb sets the recursion limit (max depth) for the pattern": "",
    "This will match only at the starting point of the search or the position the previous successful match ended. Useful with the {1} flag, or when you are only trying to match after a certain point in a string.": "",
    "This will return a portion of the source string that follows the match.": "",
    "This will return a portion of the source string that precedes the match.": "",
    "This will return a string with the complete match result from the regex.": "",
    "This will return a string with the contents from the capture group named `foo`. Any name can be used as long as it is defined in the regex. This syntax is made up and specific to only Regex101. If the J-flag is specified, content will be taken from the first capture group with the same name.": "",
    "This will return a string with the contents from the first capture group. The number, in this case 1, can be any number as long as it corresponds to a valid capture group.": "",
    "time": "",
    "Timeout": "",
    "times": "",
    "Title": "",
    "Title of regular expression": "",
    "To reduce ambiguity one may also use {1}, or {2} where `#` is a digit.": "",
    "Tools": "",
    "Transforms text to lowercase until either end of string or a {1} token is encountered. This is a feature only available on regex101.com.": "",
    "Transforms text to uppercase until either the end of string or a {1} token is encountered. This is a feature only available on regex101.com.": "",
    "Try launching the debugger to find out why.": "",
    "Twitter": "",
    "UCP (Unicode Character Properties) makes the PCRE engine extend {1}, {2}, {3}, {4}, {5}, {6}, {7}, {8}, and some POSIX character classes to include unicode characters as well, not just ASCII.": "",
    "Unable to fetch detailed task statistics. Please try again later.": "",
    "Unable to fetch list of changes, please try again later": "",
    "Unable to fetch versions": "",
    "Unable to initialize the regex engine! Please try to reload the web page. If the issue persists, please open an issue here: {1}": "",
    "Unable to save changes, please try again": "",
    "Undescribed specific verb; No description for it yet (nothing's perfect)": "",
    "Unfavorite Regex": "",
    "Ungreedy": "",
    "Unicode": "",
    "Unicode Character Table": "",
    "Unicode newlines": "",
    "Unicode property or script category": "",
    "Unicode property X": "",
    "Unit Tests": "",
    "Unit Tests {1}": "",
    "unlimited": "",
    "Unmatched opening bracket": "",
    "Unmatched parenthesis": "",
    "Unspecified unit test": "",
    "Update": "",
    "Update Library Entry": "",
    "Update Library Regex": "",
    "Update Regex": "",
    "Update Regular Expression": "",
    "Upload to Library": "",
    "uppercase": "",
    "Uppercase letters": "",
    "Uppercase Transformation": "",
    "Upvote": "",
    "Used to mark internal engine backtracking. When used in conjunction with the /K modifier (show backtracking control names), pcretest can return the mark together with a successful match. Equivalent to (*:NAME). `NAME` does not need to be unique.": "",
    "User Distribution (%)": "",
    "Usually referred to as a `backreference`, this will match a repeat of the text matched and captured by the capture group # (number) specified.": "",
    "Values below {1} are not recommended. Use at your own discretion": "",
    "verb synonymous with {1}. Forces a matching failure at the given position in the pattern": "",
    "Version {1}": "",
    "Vertical whitespace character": "",
    "View Explanation": "",
    "View Match Information": "",
    "View Regex Quick Reference": "",
    "Visible characters": "",
    "Visible characters (not space)": "",
    "Visible punctuation characters": "",
    "Visualize whitespace and other special characters": "",
    "Welcome to the RegEx101 regex quiz.": "",
    "What's new?": "",
    "Whats new?": "",
    "Whitespace": "",
    "Whole match is {1} and its start/end positions can be obtained via {2} and {3}": "",
    "Wiki": "",
    "Wiki (Info & FAQ)": "",
    "with no special consideration for the \\r\\n sequence": "",
    "Word characters": "",
    "Wrap Long Lines": "",
    "Write": "",
    "Yes, delete": "",
    "You can also unset flags using a minus sign: {1}, and can combine enabling and disabling flags. For example: {2} would set enable single line and disable case insensitive.": "",
    "You can continue to edit in this workspace without affecting the entry you just submitted.": "",
    "You can find the library entry here: {1}": "",
    "You can manually specify the number of replacements by changing the 4th argument": "",
    "You can not create a range with a shorthand escape sequences": "",
    "You can not set both the {1} and {2} flag simultaneously": "",
    "You can use alternates locally as part of a capturing/non-capturing group. For example: {1}": "",
    "You can use hexadecimals to insert any character into the replacement string using the standard syntax.": "",
    "You have made changes since you last saved, leaving the website will result in a permanent loss of the data.": "",
    "You have no tags yet, add some and organize your entries!": "",
    "You have not added anything to your favorites yet.": "",
    "You have not created anything yourself yet.": "",
    "You have not submitted anything to the library yet.": "",
    "You may not use a null byte in your regex, as that effectively terminates it at that position": "",
    "You must be signed in to vote": "",
    "You need to be signed in to participate in the regex quiz. You can do so by clicking the button in the left sidebar.": "",
    "Your expression caused an unhandled error:": "",
    "Your expression took too long to finish and was terminated. Please increase the timeout and try again.": "",
    "Your pattern contains one or more errors, please see the explanation section above.": "",
    "Your regex has been permanently saved and may be accessed with this link by anybody you give it to.": "",
    "Your regular expression does not match the subject string.": "",
    "Your search did not match anything": "",
    "Your shortest solution thus far is {1} characters long. The overall shortest solution is {2} characters long.": "",
    "Your solution with a score of {1} is better than {2}% of all submissions.": "",
    "Your tag filtration returned no results.": "",
    "Your workspace has been successfully submitted to the library!": "",
    "zero": "",
    "Zero or more of a": "",
    "Zero or one of a": ""
}
